// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Google Service Control API (servicecontrol/v1)
// Description:
//   Google Service Control provides control plane functionality to managed
//   services, such as logging, monitoring, and status checks.
// Documentation:
//   https://cloud.google.com/service-control/

#if GTLR_BUILT_AS_FRAMEWORK
  #import "GTLR/GTLRObject.h"
#else
  #import "GTLRObject.h"
#endif

#if GTLR_RUNTIME_VERSION != 3000
#error This file was generated by a different version of ServiceGenerator which is incompatible with this GTLR library source.
#endif

@class GTLRServiceControl_CheckError;
@class GTLRServiceControl_Distribution;
@class GTLRServiceControl_ExplicitBuckets;
@class GTLRServiceControl_ExponentialBuckets;
@class GTLRServiceControl_LinearBuckets;
@class GTLRServiceControl_LogEntry;
@class GTLRServiceControl_LogEntryLabels;
@class GTLRServiceControl_LogEntryProtoPayload;
@class GTLRServiceControl_LogEntryStructPayload;
@class GTLRServiceControl_MetricValue;
@class GTLRServiceControl_MetricValueLabels;
@class GTLRServiceControl_MetricValueSet;
@class GTLRServiceControl_Operation;
@class GTLRServiceControl_OperationLabels;
@class GTLRServiceControl_ReportError;
@class GTLRServiceControl_Status;
@class GTLRServiceControl_StatusDetailsItem;

NS_ASSUME_NONNULL_BEGIN

// ----------------------------------------------------------------------------
// Constants - For some of the classes' properties below.

// ----------------------------------------------------------------------------
// GTLRServiceControl_CheckError.code

/**
 *  The consumer's API Key has expired.
 *
 *  Value: "API_KEY_EXPIRED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyExpired;
/**
 *  The consumer's API key is invalid.
 *
 *  Value: "API_KEY_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyInvalid;
/**
 *  The consumer's API Key was not found in config record.
 *
 *  Value: "API_KEY_NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ApiKeyNotFound;
/**
 *  The consumer cannot access the service because billing is disabled.
 *
 *  Value: "BILLING_DISABLED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_BillingDisabled;
/**
 *  The backend server for checking billing status is unavailable.
 *
 *  Value: "BILLING_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_BillingStatusUnavailable;
/**
 *  The client application of the consumer request is invalid for the
 *  specific consumer project.
 *
 *  Value: "CLIENT_APP_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ClientAppBlocked;
/**
 *  This is never used in `CheckResponse`.
 *
 *  Value: "ERROR_CODE_UNSPECIFIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ErrorCodeUnspecified;
/**
 *  The IP address of the consumer is invalid for the specific consumer
 *  project.
 *
 *  Value: "IP_ADDRESS_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_IpAddressBlocked;
/**
 *  The backend server for looking up project id/number is unavailable.
 *
 *  Value: "NAMESPACE_LOOKUP_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_NamespaceLookupUnavailable;
/**
 *  The consumer's project id was not found.
 *  Same as google.rpc.Code.NOT_FOUND.
 *
 *  Value: "NOT_FOUND"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_NotFound;
/**
 *  The consumer doesn't have access to the specified resource.
 *  Same as google.rpc.Code.PERMISSION_DENIED.
 *
 *  Value: "PERMISSION_DENIED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_PermissionDenied;
/**
 *  The consumer's project has been marked as deleted (soft deletion).
 *
 *  Value: "PROJECT_DELETED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ProjectDeleted;
/**
 *  The consumer's project number or id does not represent a valid project.
 *
 *  Value: "PROJECT_INVALID"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ProjectInvalid;
/**
 *  The referer address of the consumer request is invalid for the specific
 *  consumer project.
 *
 *  Value: "REFERER_BLOCKED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_RefererBlocked;
/**
 *  Quota check failed. Same as google.rpc.Code.RESOURCE_EXHAUSTED.
 *
 *  Value: "RESOURCE_EXHAUSTED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ResourceExhausted;
/**
 *  The consumer hasn't activated the service.
 *
 *  Value: "SERVICE_NOT_ACTIVATED"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ServiceNotActivated;
/**
 *  The backend server for checking service status is unavailable.
 *
 *  Value: "SERVICE_STATUS_UNAVAILABLE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_CheckError_Code_ServiceStatusUnavailable;

// ----------------------------------------------------------------------------
// GTLRServiceControl_LogEntry.severity

/**
 *  (700) A person must take an action immediately.
 *
 *  Value: "ALERT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Alert;
/**
 *  (600) Critical events cause more severe problems or outages.
 *
 *  Value: "CRITICAL"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Critical;
/**
 *  (100) Debug or trace information.
 *
 *  Value: "DEBUG"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Debug;
/**
 *  (0) The log entry has no assigned severity level.
 *
 *  Value: "DEFAULT"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Default;
/**
 *  (800) One or more systems are unusable.
 *
 *  Value: "EMERGENCY"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Emergency;
/**
 *  (500) Error events are likely to cause problems.
 *
 *  Value: "ERROR"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Error;
/**
 *  (200) Routine information, such as ongoing status or performance.
 *
 *  Value: "INFO"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Info;
/**
 *  (300) Normal but significant events, such as start up, shut down, or
 *  a configuration change.
 *
 *  Value: "NOTICE"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Notice;
/**
 *  (400) Warning events might cause problems.
 *
 *  Value: "WARNING"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_LogEntry_Severity_Warning;

// ----------------------------------------------------------------------------
// GTLRServiceControl_Operation.importance

/**
 *  The API implementation doesn't cache and aggregate the data.
 *  If the method returns successfully, it's guaranteed that the data has
 *  been persisted in durable storage.
 *
 *  Value: "HIGH"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_Operation_Importance_High;
/**
 *  The API implementation may cache and aggregate the data.
 *  The data may be lost when rare and unexpected system failures occur.
 *
 *  Value: "LOW"
 */
GTLR_EXTERN NSString * const kGTLRServiceControl_Operation_Importance_Low;

/**
 *  Defines the errors to be returned in
 *  google.api.servicecontrol.v1.CheckResponse.check_errors.
 */
@interface GTLRServiceControl_CheckError : GTLRObject

/**
 *  The error code.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyExpired The consumer's
 *        API Key has expired. (Value: "API_KEY_EXPIRED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyInvalid The consumer's
 *        API key is invalid. (Value: "API_KEY_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ApiKeyNotFound The consumer's
 *        API Key was not found in config record. (Value: "API_KEY_NOT_FOUND")
 *    @arg @c kGTLRServiceControl_CheckError_Code_BillingDisabled The consumer
 *        cannot access the service because billing is disabled. (Value:
 *        "BILLING_DISABLED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_BillingStatusUnavailable The
 *        backend server for checking billing status is unavailable. (Value:
 *        "BILLING_STATUS_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ClientAppBlocked The client
 *        application of the consumer request is invalid for the
 *        specific consumer project. (Value: "CLIENT_APP_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ErrorCodeUnspecified This is
 *        never used in `CheckResponse`. (Value: "ERROR_CODE_UNSPECIFIED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_IpAddressBlocked The IP
 *        address of the consumer is invalid for the specific consumer
 *        project. (Value: "IP_ADDRESS_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_NamespaceLookupUnavailable The
 *        backend server for looking up project id/number is unavailable.
 *        (Value: "NAMESPACE_LOOKUP_UNAVAILABLE")
 *    @arg @c kGTLRServiceControl_CheckError_Code_NotFound The consumer's
 *        project id was not found.
 *        Same as google.rpc.Code.NOT_FOUND. (Value: "NOT_FOUND")
 *    @arg @c kGTLRServiceControl_CheckError_Code_PermissionDenied The consumer
 *        doesn't have access to the specified resource.
 *        Same as google.rpc.Code.PERMISSION_DENIED. (Value:
 *        "PERMISSION_DENIED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ProjectDeleted The consumer's
 *        project has been marked as deleted (soft deletion). (Value:
 *        "PROJECT_DELETED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ProjectInvalid The consumer's
 *        project number or id does not represent a valid project. (Value:
 *        "PROJECT_INVALID")
 *    @arg @c kGTLRServiceControl_CheckError_Code_RefererBlocked The referer
 *        address of the consumer request is invalid for the specific
 *        consumer project. (Value: "REFERER_BLOCKED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ResourceExhausted Quota check
 *        failed. Same as google.rpc.Code.RESOURCE_EXHAUSTED. (Value:
 *        "RESOURCE_EXHAUSTED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ServiceNotActivated The
 *        consumer hasn't activated the service. (Value:
 *        "SERVICE_NOT_ACTIVATED")
 *    @arg @c kGTLRServiceControl_CheckError_Code_ServiceStatusUnavailable The
 *        backend server for checking service status is unavailable. (Value:
 *        "SERVICE_STATUS_UNAVAILABLE")
 */
@property(nonatomic, copy, nullable) NSString *code;

/** Free-form text providing details on the error cause of the error. */
@property(nonatomic, copy, nullable) NSString *detail;

@end


/**
 *  Request message for the Check method.
 */
@interface GTLRServiceControl_CheckRequest : GTLRObject

/** The operation to be checked. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Operation *operation;

@end


/**
 *  Response message for the Check method.
 */
@interface GTLRServiceControl_CheckResponse : GTLRObject

/**
 *  Indicate the decision of the check.
 *  If no check errors are present, the service should process the operation.
 *  Otherwise the service should use the list of errors to determine the
 *  appropriate action.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_CheckError *> *checkErrors;

/**
 *  The same operation_id value used in the CheckRequest.
 *  Used for logging and diagnostics purposes.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** The actual config id used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  Distribution represents a frequency distribution of double-valued sample
 *  points. It contains the size of the population of sample points plus
 *  additional optional information:
 *  - the arithmetic mean of the samples
 *  - the minimum and maximum of the samples
 *  - the sum-squared-deviation of the samples, used to compute variance
 *  - a histogram of the values of the sample points
 */
@interface GTLRServiceControl_Distribution : GTLRObject

/**
 *  The number of samples in each histogram bucket. `bucket_counts` are
 *  optional. If present, they must sum to the `count` value.
 *  The buckets are defined below in `bucket_option`. There are N buckets.
 *  `bucket_counts[0]` is the number of samples in the underflow bucket.
 *  `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
 *  in each of the finite buckets. And `bucket_counts[N] is the number
 *  of samples in the overflow bucket. See the comments of `bucket_option`
 *  below for more details.
 *  Any suffix of trailing zeros may be omitted.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bucketCounts;

/**
 *  The total number of samples in the distribution. Must be >= 0.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *count;

/** Buckets with arbitrary user-provided width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_ExplicitBuckets *explicitBuckets;

/** Buckets with exponentially growing width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_ExponentialBuckets *exponentialBuckets;

/** Buckets with constant width. */
@property(nonatomic, strong, nullable) GTLRServiceControl_LinearBuckets *linearBuckets;

/**
 *  The maximum of the population of values. Ignored if `count` is zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *maximum;

/**
 *  The arithmetic mean of the samples in the distribution. If `count` is
 *  zero then this field must be zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *mean;

/**
 *  The minimum of the population of values. Ignored if `count` is zero.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *minimum;

/**
 *  The sum of squared deviations from the mean:
 *  Sum[i=1..count]((x_i - mean)^2)
 *  where each x_i is a sample values. If `count` is zero then this field
 *  must be zero, otherwise validation of the request fails.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *sumOfSquaredDeviation;

@end


/**
 *  Describing buckets with arbitrary user-provided width.
 */
@interface GTLRServiceControl_ExplicitBuckets : GTLRObject

/**
 *  'bound' is a list of strictly increasing boundaries between
 *  buckets. Note that a list of length N-1 defines N buckets because
 *  of fenceposting. See comments on `bucket_options` for details.
 *  The i'th finite bucket covers the interval
 *  [bound[i-1], bound[i])
 *  where i ranges from 1 to bound_size() - 1. Note that there are no
 *  finite buckets at all if 'bound' only contains a single element; in
 *  that special case the single bound defines the boundary between the
 *  underflow and overflow buckets.
 *  bucket number lower bound upper bound
 *  i == 0 (underflow) -inf bound[i]
 *  0 < i < bound_size() bound[i-1] bound[i]
 *  i == bound_size() (overflow) bound[i-1] +inf
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSArray<NSNumber *> *bounds;

@end


/**
 *  Describing buckets with exponentially growing width.
 */
@interface GTLRServiceControl_ExponentialBuckets : GTLRObject

/**
 *  The i'th exponential bucket covers the interval
 *  [scale * growth_factor^(i-1), scale * growth_factor^i)
 *  where i ranges from 1 to num_finite_buckets inclusive.
 *  Must be larger than 1.0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *growthFactor;

/**
 *  The number of finite buckets. With the underflow and overflow buckets,
 *  the total number of buckets is `num_finite_buckets` + 2.
 *  See comments on `bucket_options` for details.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  The i'th exponential bucket covers the interval
 *  [scale * growth_factor^(i-1), scale * growth_factor^i)
 *  where i ranges from 1 to num_finite_buckets inclusive.
 *  Must be > 0.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *scale;

@end


/**
 *  Describing buckets with constant width.
 */
@interface GTLRServiceControl_LinearBuckets : GTLRObject

/**
 *  The number of finite buckets. With the underflow and overflow buckets,
 *  the total number of buckets is `num_finite_buckets` + 2.
 *  See comments on `bucket_options` for details.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *numFiniteBuckets;

/**
 *  The i'th linear bucket covers the interval
 *  [offset + (i-1) * width, offset + i * width)
 *  where i ranges from 1 to num_finite_buckets, inclusive.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *offset;

/**
 *  The i'th linear bucket covers the interval
 *  [offset + (i-1) * width, offset + i * width)
 *  where i ranges from 1 to num_finite_buckets, inclusive.
 *  Must be strictly positive.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *width;

@end


/**
 *  An individual log entry.
 */
@interface GTLRServiceControl_LogEntry : GTLRObject

/**
 *  A unique ID for the log entry used for deduplication. If omitted,
 *  the implementation will generate one based on operation_id.
 */
@property(nonatomic, copy, nullable) NSString *insertId;

/**
 *  A set of user-defined (key, value) data that provides additional
 *  information about the log entry.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntryLabels *labels;

/**
 *  Required. The log to which this log entry belongs. Examples: `"syslog"`,
 *  `"book_log"`.
 */
@property(nonatomic, copy, nullable) NSString *name;

/**
 *  The log entry payload, represented as a protocol buffer that is
 *  expressed as a JSON object. You can only pass `protoPayload`
 *  values that belong to a set of approved types.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntryProtoPayload *protoPayload;

/**
 *  The severity of the log entry. The default value is
 *  `LogSeverity.DEFAULT`.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Alert (700) A person must
 *        take an action immediately. (Value: "ALERT")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Critical (600) Critical
 *        events cause more severe problems or outages. (Value: "CRITICAL")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Debug (100) Debug or trace
 *        information. (Value: "DEBUG")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Default (0) The log entry
 *        has no assigned severity level. (Value: "DEFAULT")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Emergency (800) One or more
 *        systems are unusable. (Value: "EMERGENCY")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Error (500) Error events are
 *        likely to cause problems. (Value: "ERROR")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Info (200) Routine
 *        information, such as ongoing status or performance. (Value: "INFO")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Notice (300) Normal but
 *        significant events, such as start up, shut down, or
 *        a configuration change. (Value: "NOTICE")
 *    @arg @c kGTLRServiceControl_LogEntry_Severity_Warning (400) Warning events
 *        might cause problems. (Value: "WARNING")
 */
@property(nonatomic, copy, nullable) NSString *severity;

/**
 *  The log entry payload, represented as a structure that
 *  is expressed as a JSON object.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_LogEntryStructPayload *structPayload;

/** The log entry payload, represented as a Unicode string (UTF-8). */
@property(nonatomic, copy, nullable) NSString *textPayload;

/**
 *  The time the event described by the log entry occurred. If
 *  omitted, defaults to operation start time.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *timestamp;

@end


/**
 *  A set of user-defined (key, value) data that provides additional
 *  information about the log entry.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_LogEntryLabels : GTLRObject
@end


/**
 *  The log entry payload, represented as a protocol buffer that is
 *  expressed as a JSON object. You can only pass `protoPayload`
 *  values that belong to a set of approved types.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_LogEntryProtoPayload : GTLRObject
@end


/**
 *  The log entry payload, represented as a structure that
 *  is expressed as a JSON object.
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_LogEntryStructPayload : GTLRObject
@end


/**
 *  Represents a single metric value.
 */
@interface GTLRServiceControl_MetricValue : GTLRObject

/**
 *  A boolean value.
 *
 *  Uses NSNumber of boolValue.
 */
@property(nonatomic, strong, nullable) NSNumber *boolValue;

/** A distribution value. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Distribution *distributionValue;

/**
 *  A double precision floating point value.
 *
 *  Uses NSNumber of doubleValue.
 */
@property(nonatomic, strong, nullable) NSNumber *doubleValue;

/**
 *  The end of the time period over which this metric value's measurement
 *  applies.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  A signed 64-bit integer value.
 *
 *  Uses NSNumber of longLongValue.
 */
@property(nonatomic, strong, nullable) NSNumber *int64Value;

/**
 *  The labels describing the metric value.
 *  See comments on google.api.servicecontrol.v1.Operation.labels for
 *  the overriding relationship.
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_MetricValueLabels *labels;

/**
 *  The start of the time period over which this metric value's measurement
 *  applies. The time period has different semantics for different metric
 *  types (cumulative, delta, and gauge). See the metric definition
 *  documentation in the service configuration for details.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

/** A text string value. */
@property(nonatomic, copy, nullable) NSString *stringValue;

@end


/**
 *  The labels describing the metric value.
 *  See comments on google.api.servicecontrol.v1.Operation.labels for
 *  the overriding relationship.
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_MetricValueLabels : GTLRObject
@end


/**
 *  Represents a set of metric values in the same metric.
 *  Each metric value in the set should have a unique combination of start time,
 *  end time, and label values.
 */
@interface GTLRServiceControl_MetricValueSet : GTLRObject

/** The metric name defined in the service configuration. */
@property(nonatomic, copy, nullable) NSString *metricName;

/** The values in this metric. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValue *> *metricValues;

@end


/**
 *  Represents information regarding an operation.
 */
@interface GTLRServiceControl_Operation : GTLRObject

/**
 *  Identity of the consumer who is using the service.
 *  This field should be filled in for the operations initiated by a
 *  consumer, but not for service-initiated operations that are
 *  not related to a specific consumer.
 *  This can be in one of the following formats:
 *  project:<project_id>,
 *  project_number:<project_number>,
 *  api_key:<api_key>.
 */
@property(nonatomic, copy, nullable) NSString *consumerId;

/**
 *  End time of the operation.
 *  Required when the operation is used in ServiceController.Report,
 *  but optional when the operation is used in ServiceController.Check.
 */
@property(nonatomic, strong, nullable) GTLRDateTime *endTime;

/**
 *  DO NOT USE. This is an experimental field.
 *
 *  Likely values:
 *    @arg @c kGTLRServiceControl_Operation_Importance_High The API
 *        implementation doesn't cache and aggregate the data.
 *        If the method returns successfully, it's guaranteed that the data has
 *        been persisted in durable storage. (Value: "HIGH")
 *    @arg @c kGTLRServiceControl_Operation_Importance_Low The API
 *        implementation may cache and aggregate the data.
 *        The data may be lost when rare and unexpected system failures occur.
 *        (Value: "LOW")
 */
@property(nonatomic, copy, nullable) NSString *importance;

/**
 *  Labels describing the operation. Only the following labels are allowed:
 *  - Labels describing monitored resources as defined in
 *  the service configuration.
 *  - Default labels of metric values. When specified, labels defined in the
 *  metric value override these default.
 *  - The following labels defined by Google Cloud Platform:
 *  - `cloud.googleapis.com/location` describing the location where the
 *  operation happened,
 *  - `servicecontrol.googleapis.com/user_agent` describing the user agent
 *  of the API request,
 *  - `servicecontrol.googleapis.com/service_agent` describing the service
 *  used to handle the API request (e.g. ESP),
 *  - `servicecontrol.googleapis.com/platform` describing the platform
 *  where the API is served (e.g. GAE, GCE, GKE).
 */
@property(nonatomic, strong, nullable) GTLRServiceControl_OperationLabels *labels;

/** Represents information to be logged. */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_LogEntry *> *logEntries;

/**
 *  Represents information about this operation. Each MetricValueSet
 *  corresponds to a metric defined in the service configuration.
 *  The data type used in the MetricValueSet must agree with
 *  the data type specified in the metric definition.
 *  Within a single operation, it is not allowed to have more than one
 *  MetricValue instances that have the same metric names and identical
 *  label value combinations. If a request has such duplicated MetricValue
 *  instances, the entire request is rejected with
 *  an invalid argument error.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_MetricValueSet *> *metricValueSets;

/**
 *  Identity of the operation. This must be unique within the scope of the
 *  service that generated the operation. If the service calls
 *  Check() and Report() on the same operation, the two calls should carry
 *  the same id.
 *  UUID version 4 is recommended, though not required.
 *  In scenarios where an operation is computed from existing information
 *  and an idempotent id is desirable for deduplication purpose, UUID version 5
 *  is recommended. See RFC 4122 for details.
 */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Fully qualified name of the operation. Reserved for future use. */
@property(nonatomic, copy, nullable) NSString *operationName;

/** Required. Start time of the operation. */
@property(nonatomic, strong, nullable) GTLRDateTime *startTime;

@end


/**
 *  Labels describing the operation. Only the following labels are allowed:
 *  - Labels describing monitored resources as defined in
 *  the service configuration.
 *  - Default labels of metric values. When specified, labels defined in the
 *  metric value override these default.
 *  - The following labels defined by Google Cloud Platform:
 *  - `cloud.googleapis.com/location` describing the location where the
 *  operation happened,
 *  - `servicecontrol.googleapis.com/user_agent` describing the user agent
 *  of the API request,
 *  - `servicecontrol.googleapis.com/service_agent` describing the service
 *  used to handle the API request (e.g. ESP),
 *  - `servicecontrol.googleapis.com/platform` describing the platform
 *  where the API is served (e.g. GAE, GCE, GKE).
 *
 *  @note This class is documented as having more properties of NSString. Use @c
 *        -additionalJSONKeys and @c -additionalPropertyForName: to get the list
 *        of properties and then fetch them; or @c -additionalProperties to
 *        fetch them all at once.
 */
@interface GTLRServiceControl_OperationLabels : GTLRObject
@end


/**
 *  Represents the processing error of one `Operation` in the request.
 */
@interface GTLRServiceControl_ReportError : GTLRObject

/** The Operation.operation_id value from the request. */
@property(nonatomic, copy, nullable) NSString *operationId;

/** Details of the error when processing the `Operation`. */
@property(nonatomic, strong, nullable) GTLRServiceControl_Status *status;

@end


/**
 *  Request message for the Report method.
 */
@interface GTLRServiceControl_ReportRequest : GTLRObject

/**
 *  Operations to be reported.
 *  Typically the service should report one operation per request.
 *  Putting multiple operations into a single request is allowed, but should
 *  be used only when multiple operations are natually available at the time
 *  of the report.
 *  If multiple operations are in a single request, the total request size
 *  should be no larger than 1MB. See ReportResponse.report_errors for
 *  partial failure behavior.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_Operation *> *operations;

@end


/**
 *  Response message for the Report method.
 */
@interface GTLRServiceControl_ReportResponse : GTLRObject

/**
 *  Partial failures, one for each `Operation` in the request that failed
 *  processing. There are three possible combinations of the RPC status:
 *  1. The combination of a successful RPC status and an empty `report_errors`
 *  list indicates a complete success where all `Operations` in the
 *  request are processed successfully.
 *  2. The combination of a successful RPC status and a non-empty
 *  `report_errors` list indicates a partial success where some
 *  `Operations` in the request succeeded. Each
 *  `Operation` that failed processing has a corresponding item
 *  in this list.
 *  3. A failed RPC status indicates a complete failure where none of the
 *  `Operations` in the request succeeded.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_ReportError *> *reportErrors;

/** The actual config id used to process the request. */
@property(nonatomic, copy, nullable) NSString *serviceConfigId;

@end


/**
 *  The `Status` type defines a logical error model that is suitable for
 *  different
 *  programming environments, including REST APIs and RPC APIs. It is used by
 *  [gRPC](https://github.com/grpc). The error model is designed to be:
 *  - Simple to use and understand for most users
 *  - Flexible enough to meet unexpected needs
 *  # Overview
 *  The `Status` message contains three pieces of data: error code, error
 *  message,
 *  and error details. The error code should be an enum value of
 *  google.rpc.Code, but it may accept additional error codes if needed. The
 *  error message should be a developer-facing English message that helps
 *  developers *understand* and *resolve* the error. If a localized user-facing
 *  error message is needed, put the localized message in the error details or
 *  localize it in the client. The optional error details may contain arbitrary
 *  information about the error. There is a predefined set of error detail types
 *  in the package `google.rpc` which can be used for common error conditions.
 *  # Language mapping
 *  The `Status` message is the logical representation of the error model, but
 *  it
 *  is not necessarily the actual wire format. When the `Status` message is
 *  exposed in different client libraries and different wire protocols, it can
 *  be
 *  mapped differently. For example, it will likely be mapped to some exceptions
 *  in Java, but more likely mapped to some error codes in C.
 *  # Other uses
 *  The error model and the `Status` message can be used in a variety of
 *  environments, either with or without APIs, to provide a
 *  consistent developer experience across different environments.
 *  Example uses of this error model include:
 *  - Partial errors. If a service needs to return partial errors to the client,
 *  it may embed the `Status` in the normal response to indicate the partial
 *  errors.
 *  - Workflow errors. A typical workflow has multiple steps. Each step may
 *  have a `Status` message for error reporting purpose.
 *  - Batch operations. If a client uses batch request and batch response, the
 *  `Status` message should be used directly inside batch response, one for
 *  each error sub-response.
 *  - Asynchronous operations. If an API call embeds asynchronous operation
 *  results in its response, the status of those operations should be
 *  represented directly using the `Status` message.
 *  - Logging. If some API errors are stored in logs, the message `Status` could
 *  be used directly after any stripping needed for security/privacy reasons.
 */
@interface GTLRServiceControl_Status : GTLRObject

/**
 *  The status code, which should be an enum value of google.rpc.Code.
 *
 *  Uses NSNumber of intValue.
 */
@property(nonatomic, strong, nullable) NSNumber *code;

/**
 *  A list of messages that carry the error details. There will be a
 *  common set of message types for APIs to use.
 */
@property(nonatomic, strong, nullable) NSArray<GTLRServiceControl_StatusDetailsItem *> *details;

/**
 *  A developer-facing error message, which should be in English. Any
 *  user-facing error message should be localized and sent in the
 *  google.rpc.Status.details field, or localized by the client.
 */
@property(nonatomic, copy, nullable) NSString *message;

@end


/**
 *  GTLRServiceControl_StatusDetailsItem
 *
 *  @note This class is documented as having more properties of any valid JSON
 *        type. Use @c -additionalJSONKeys and @c -additionalPropertyForName: to
 *        get the list of properties and then fetch them; or @c
 *        -additionalProperties to fetch them all at once.
 */
@interface GTLRServiceControl_StatusDetailsItem : GTLRObject
@end

NS_ASSUME_NONNULL_END
