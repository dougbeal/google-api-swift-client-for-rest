// NOTE: This file was generated by the ServiceGenerator.

// ----------------------------------------------------------------------------
// API:
//   Compute Engine API (compute/v1)
// Description:
//   Creates and runs virtual machines on Google Cloud Platform.
// Documentation:
//   https://developers.google.com/compute/docs/reference/latest/

#import "GTLRComputeObjects.h"

// ----------------------------------------------------------------------------
// Constants

// GTLRCompute_AccessConfig.type
NSString * const kGTLRCompute_AccessConfig_Type_OneToOneNat = @"ONE_TO_ONE_NAT";

// GTLRCompute_Address.status
NSString * const kGTLRCompute_Address_Status_InUse    = @"IN_USE";
NSString * const kGTLRCompute_Address_Status_Reserved = @"RESERVED";

// GTLRCompute_AddressesScopedListWarning.code
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_AddressesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_AttachedDisk.interface
NSString * const kGTLRCompute_AttachedDisk_Interface_Nvme = @"NVME";
NSString * const kGTLRCompute_AttachedDisk_Interface_Scsi = @"SCSI";

// GTLRCompute_AttachedDisk.mode
NSString * const kGTLRCompute_AttachedDisk_Mode_ReadOnly  = @"READ_ONLY";
NSString * const kGTLRCompute_AttachedDisk_Mode_ReadWrite = @"READ_WRITE";

// GTLRCompute_AttachedDisk.type
NSString * const kGTLRCompute_AttachedDisk_Type_Persistent = @"PERSISTENT";
NSString * const kGTLRCompute_AttachedDisk_Type_Scratch    = @"SCRATCH";

// GTLRCompute_AutoscalersScopedListWarning.code
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_AutoscalersScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_AutoscalingPolicyCustomMetricUtilization.utilizationTargetType
NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerMinute = @"DELTA_PER_MINUTE";
NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_DeltaPerSecond = @"DELTA_PER_SECOND";
NSString * const kGTLRCompute_AutoscalingPolicyCustomMetricUtilization_UtilizationTargetType_Gauge = @"GAUGE";

// GTLRCompute_Backend.balancingMode
NSString * const kGTLRCompute_Backend_BalancingMode_Connection = @"CONNECTION";
NSString * const kGTLRCompute_Backend_BalancingMode_Rate       = @"RATE";
NSString * const kGTLRCompute_Backend_BalancingMode_Utilization = @"UTILIZATION";

// GTLRCompute_BackendService.protocol
NSString * const kGTLRCompute_BackendService_Protocol_Http  = @"HTTP";
NSString * const kGTLRCompute_BackendService_Protocol_Https = @"HTTPS";
NSString * const kGTLRCompute_BackendService_Protocol_Ssl   = @"SSL";
NSString * const kGTLRCompute_BackendService_Protocol_Tcp   = @"TCP";

// GTLRCompute_BackendService.sessionAffinity
NSString * const kGTLRCompute_BackendService_SessionAffinity_ClientIp = @"CLIENT_IP";
NSString * const kGTLRCompute_BackendService_SessionAffinity_ClientIpProto = @"CLIENT_IP_PROTO";
NSString * const kGTLRCompute_BackendService_SessionAffinity_GeneratedCookie = @"GENERATED_COOKIE";
NSString * const kGTLRCompute_BackendService_SessionAffinity_None = @"NONE";

// GTLRCompute_DeprecationStatus.state
NSString * const kGTLRCompute_DeprecationStatus_State_Deleted  = @"DELETED";
NSString * const kGTLRCompute_DeprecationStatus_State_Deprecated = @"DEPRECATED";
NSString * const kGTLRCompute_DeprecationStatus_State_Obsolete = @"OBSOLETE";

// GTLRCompute_Disk.status
NSString * const kGTLRCompute_Disk_Status_Creating  = @"CREATING";
NSString * const kGTLRCompute_Disk_Status_Failed    = @"FAILED";
NSString * const kGTLRCompute_Disk_Status_Ready     = @"READY";
NSString * const kGTLRCompute_Disk_Status_Restoring = @"RESTORING";

// GTLRCompute_DisksScopedListWarning.code
NSString * const kGTLRCompute_DisksScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_DisksScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_DiskTypesScopedListWarning.code
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_DiskTypesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_ForwardingRule.IPProtocol
NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Ah   = @"AH";
NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Esp  = @"ESP";
NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Sctp = @"SCTP";
NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Tcp  = @"TCP";
NSString * const kGTLRCompute_ForwardingRule_IPProtocol_Udp  = @"UDP";

// GTLRCompute_ForwardingRulesScopedListWarning.code
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_ForwardingRulesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_HealthCheck.type
NSString * const kGTLRCompute_HealthCheck_Type_Http    = @"HTTP";
NSString * const kGTLRCompute_HealthCheck_Type_Http2   = @"HTTP2";
NSString * const kGTLRCompute_HealthCheck_Type_Https   = @"HTTPS";
NSString * const kGTLRCompute_HealthCheck_Type_Invalid = @"INVALID";
NSString * const kGTLRCompute_HealthCheck_Type_Ssl     = @"SSL";
NSString * const kGTLRCompute_HealthCheck_Type_Tcp     = @"TCP";

// GTLRCompute_HealthStatus.healthState
NSString * const kGTLRCompute_HealthStatus_HealthState_Healthy = @"HEALTHY";
NSString * const kGTLRCompute_HealthStatus_HealthState_Unhealthy = @"UNHEALTHY";

// GTLRCompute_HTTP2HealthCheck.proxyHeader
NSString * const kGTLRCompute_HTTP2HealthCheck_ProxyHeader_None = @"NONE";
NSString * const kGTLRCompute_HTTP2HealthCheck_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_HTTPHealthCheck.proxyHeader
NSString * const kGTLRCompute_HTTPHealthCheck_ProxyHeader_None = @"NONE";
NSString * const kGTLRCompute_HTTPHealthCheck_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_HTTPSHealthCheck.proxyHeader
NSString * const kGTLRCompute_HTTPSHealthCheck_ProxyHeader_None = @"NONE";
NSString * const kGTLRCompute_HTTPSHealthCheck_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_Image.sourceType
NSString * const kGTLRCompute_Image_SourceType_Raw = @"RAW";

// GTLRCompute_Image.status
NSString * const kGTLRCompute_Image_Status_Failed  = @"FAILED";
NSString * const kGTLRCompute_Image_Status_Pending = @"PENDING";
NSString * const kGTLRCompute_Image_Status_Ready   = @"READY";

// GTLRCompute_ImageRawDisk.containerType
NSString * const kGTLRCompute_ImageRawDisk_ContainerType_Tar = @"TAR";

// GTLRCompute_Instance.status
NSString * const kGTLRCompute_Instance_Status_Provisioning = @"PROVISIONING";
NSString * const kGTLRCompute_Instance_Status_Running      = @"RUNNING";
NSString * const kGTLRCompute_Instance_Status_Staging      = @"STAGING";
NSString * const kGTLRCompute_Instance_Status_Stopped      = @"STOPPED";
NSString * const kGTLRCompute_Instance_Status_Stopping     = @"STOPPING";
NSString * const kGTLRCompute_Instance_Status_Suspended    = @"SUSPENDED";
NSString * const kGTLRCompute_Instance_Status_Suspending   = @"SUSPENDING";
NSString * const kGTLRCompute_Instance_Status_Terminated   = @"TERMINATED";

// GTLRCompute_InstanceGroupManagersScopedListWarning.code
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_InstanceGroupManagersScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_InstanceGroupsListInstancesRequest.instanceState
NSString * const kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_All = @"ALL";
NSString * const kGTLRCompute_InstanceGroupsListInstancesRequest_InstanceState_Running = @"RUNNING";

// GTLRCompute_InstanceGroupsScopedListWarning.code
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_InstanceGroupsScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_InstancesScopedListWarning.code
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_InstancesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_InstanceWithNamedPorts.status
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Provisioning = @"PROVISIONING";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Running = @"RUNNING";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Staging = @"STAGING";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Stopped = @"STOPPED";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Stopping = @"STOPPING";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Suspended = @"SUSPENDED";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Suspending = @"SUSPENDING";
NSString * const kGTLRCompute_InstanceWithNamedPorts_Status_Terminated = @"TERMINATED";

// GTLRCompute_MachineTypesScopedListWarning.code
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_MachineTypesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_ManagedInstance.currentAction
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Abandoning = @"ABANDONING";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Creating = @"CREATING";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_CreatingWithoutRetries = @"CREATING_WITHOUT_RETRIES";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Deleting = @"DELETING";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_None = @"NONE";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Recreating = @"RECREATING";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Refreshing = @"REFRESHING";
NSString * const kGTLRCompute_ManagedInstance_CurrentAction_Restarting = @"RESTARTING";

// GTLRCompute_ManagedInstance.instanceStatus
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Provisioning = @"PROVISIONING";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Running = @"RUNNING";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Staging = @"STAGING";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Stopped = @"STOPPED";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Stopping = @"STOPPING";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Suspended = @"SUSPENDED";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Suspending = @"SUSPENDING";
NSString * const kGTLRCompute_ManagedInstance_InstanceStatus_Terminated = @"TERMINATED";

// GTLRCompute_Operation.status
NSString * const kGTLRCompute_Operation_Status_Done    = @"DONE";
NSString * const kGTLRCompute_Operation_Status_Pending = @"PENDING";
NSString * const kGTLRCompute_Operation_Status_Running = @"RUNNING";

// GTLRCompute_OperationsScopedListWarning.code
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_OperationsScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_OperationWarningsItem.code
NSString * const kGTLRCompute_OperationWarningsItem_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_OperationWarningsItem_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_OperationWarningsItem_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_OperationWarningsItem_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_OperationWarningsItem_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_OperationWarningsItem_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_OperationWarningsItem_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_OperationWarningsItem_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_OperationWarningsItem_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_OperationWarningsItem_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_Quota.metric
NSString * const kGTLRCompute_Quota_Metric_Autoscalers         = @"AUTOSCALERS";
NSString * const kGTLRCompute_Quota_Metric_BackendServices     = @"BACKEND_SERVICES";
NSString * const kGTLRCompute_Quota_Metric_Cpus                = @"CPUS";
NSString * const kGTLRCompute_Quota_Metric_DisksTotalGb        = @"DISKS_TOTAL_GB";
NSString * const kGTLRCompute_Quota_Metric_Firewalls           = @"FIREWALLS";
NSString * const kGTLRCompute_Quota_Metric_ForwardingRules     = @"FORWARDING_RULES";
NSString * const kGTLRCompute_Quota_Metric_HealthChecks        = @"HEALTH_CHECKS";
NSString * const kGTLRCompute_Quota_Metric_Images              = @"IMAGES";
NSString * const kGTLRCompute_Quota_Metric_InstanceGroupManagers = @"INSTANCE_GROUP_MANAGERS";
NSString * const kGTLRCompute_Quota_Metric_InstanceGroups      = @"INSTANCE_GROUPS";
NSString * const kGTLRCompute_Quota_Metric_Instances           = @"INSTANCES";
NSString * const kGTLRCompute_Quota_Metric_InstanceTemplates   = @"INSTANCE_TEMPLATES";
NSString * const kGTLRCompute_Quota_Metric_InUseAddresses      = @"IN_USE_ADDRESSES";
NSString * const kGTLRCompute_Quota_Metric_LocalSsdTotalGb     = @"LOCAL_SSD_TOTAL_GB";
NSString * const kGTLRCompute_Quota_Metric_Networks            = @"NETWORKS";
NSString * const kGTLRCompute_Quota_Metric_PreemptibleCpus     = @"PREEMPTIBLE_CPUS";
NSString * const kGTLRCompute_Quota_Metric_RegionalAutoscalers = @"REGIONAL_AUTOSCALERS";
NSString * const kGTLRCompute_Quota_Metric_RegionalInstanceGroupManagers = @"REGIONAL_INSTANCE_GROUP_MANAGERS";
NSString * const kGTLRCompute_Quota_Metric_Routers             = @"ROUTERS";
NSString * const kGTLRCompute_Quota_Metric_Routes              = @"ROUTES";
NSString * const kGTLRCompute_Quota_Metric_Snapshots           = @"SNAPSHOTS";
NSString * const kGTLRCompute_Quota_Metric_SsdTotalGb          = @"SSD_TOTAL_GB";
NSString * const kGTLRCompute_Quota_Metric_SslCertificates     = @"SSL_CERTIFICATES";
NSString * const kGTLRCompute_Quota_Metric_StaticAddresses     = @"STATIC_ADDRESSES";
NSString * const kGTLRCompute_Quota_Metric_Subnetworks         = @"SUBNETWORKS";
NSString * const kGTLRCompute_Quota_Metric_TargetHttpProxies   = @"TARGET_HTTP_PROXIES";
NSString * const kGTLRCompute_Quota_Metric_TargetHttpsProxies  = @"TARGET_HTTPS_PROXIES";
NSString * const kGTLRCompute_Quota_Metric_TargetInstances     = @"TARGET_INSTANCES";
NSString * const kGTLRCompute_Quota_Metric_TargetPools         = @"TARGET_POOLS";
NSString * const kGTLRCompute_Quota_Metric_TargetSslProxies    = @"TARGET_SSL_PROXIES";
NSString * const kGTLRCompute_Quota_Metric_TargetVpnGateways   = @"TARGET_VPN_GATEWAYS";
NSString * const kGTLRCompute_Quota_Metric_UrlMaps             = @"URL_MAPS";
NSString * const kGTLRCompute_Quota_Metric_VpnTunnels          = @"VPN_TUNNELS";

// GTLRCompute_Region.status
NSString * const kGTLRCompute_Region_Status_Down = @"DOWN";
NSString * const kGTLRCompute_Region_Status_Up   = @"UP";

// GTLRCompute_RoutersScopedListWarning.code
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_RoutersScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_RouterStatusBgpPeerStatus.status
NSString * const kGTLRCompute_RouterStatusBgpPeerStatus_Status_Down = @"DOWN";
NSString * const kGTLRCompute_RouterStatusBgpPeerStatus_Status_Unknown = @"UNKNOWN";
NSString * const kGTLRCompute_RouterStatusBgpPeerStatus_Status_Up = @"UP";

// GTLRCompute_RouteWarningsItem.code
NSString * const kGTLRCompute_RouteWarningsItem_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_RouteWarningsItem_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_RouteWarningsItem_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_RouteWarningsItem_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_RouteWarningsItem_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_RouteWarningsItem_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_RouteWarningsItem_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_RouteWarningsItem_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_RouteWarningsItem_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_RouteWarningsItem_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_Scheduling.onHostMaintenance
NSString * const kGTLRCompute_Scheduling_OnHostMaintenance_Migrate = @"MIGRATE";
NSString * const kGTLRCompute_Scheduling_OnHostMaintenance_Terminate = @"TERMINATE";

// GTLRCompute_Snapshot.status
NSString * const kGTLRCompute_Snapshot_Status_Creating  = @"CREATING";
NSString * const kGTLRCompute_Snapshot_Status_Deleting  = @"DELETING";
NSString * const kGTLRCompute_Snapshot_Status_Failed    = @"FAILED";
NSString * const kGTLRCompute_Snapshot_Status_Ready     = @"READY";
NSString * const kGTLRCompute_Snapshot_Status_Uploading = @"UPLOADING";

// GTLRCompute_Snapshot.storageBytesStatus
NSString * const kGTLRCompute_Snapshot_StorageBytesStatus_Updating = @"UPDATING";
NSString * const kGTLRCompute_Snapshot_StorageBytesStatus_UpToDate = @"UP_TO_DATE";

// GTLRCompute_SSLHealthCheck.proxyHeader
NSString * const kGTLRCompute_SSLHealthCheck_ProxyHeader_None  = @"NONE";
NSString * const kGTLRCompute_SSLHealthCheck_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_SubnetworksScopedListWarning.code
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_SubnetworksScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_TargetInstance.natPolicy
NSString * const kGTLRCompute_TargetInstance_NatPolicy_NoNat = @"NO_NAT";

// GTLRCompute_TargetInstancesScopedListWarning.code
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_TargetInstancesScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_TargetPool.sessionAffinity
NSString * const kGTLRCompute_TargetPool_SessionAffinity_ClientIp = @"CLIENT_IP";
NSString * const kGTLRCompute_TargetPool_SessionAffinity_ClientIpProto = @"CLIENT_IP_PROTO";
NSString * const kGTLRCompute_TargetPool_SessionAffinity_GeneratedCookie = @"GENERATED_COOKIE";
NSString * const kGTLRCompute_TargetPool_SessionAffinity_None  = @"NONE";

// GTLRCompute_TargetPoolsScopedListWarning.code
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_TargetPoolsScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_TargetSslProxiesSetProxyHeaderRequest.proxyHeader
NSString * const kGTLRCompute_TargetSslProxiesSetProxyHeaderRequest_ProxyHeader_None = @"NONE";
NSString * const kGTLRCompute_TargetSslProxiesSetProxyHeaderRequest_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_TargetSslProxy.proxyHeader
NSString * const kGTLRCompute_TargetSslProxy_ProxyHeader_None  = @"NONE";
NSString * const kGTLRCompute_TargetSslProxy_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_TargetVpnGateway.status
NSString * const kGTLRCompute_TargetVpnGateway_Status_Creating = @"CREATING";
NSString * const kGTLRCompute_TargetVpnGateway_Status_Deleting = @"DELETING";
NSString * const kGTLRCompute_TargetVpnGateway_Status_Failed   = @"FAILED";
NSString * const kGTLRCompute_TargetVpnGateway_Status_Ready    = @"READY";

// GTLRCompute_TargetVpnGatewaysScopedListWarning.code
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_TargetVpnGatewaysScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_TCPHealthCheck.proxyHeader
NSString * const kGTLRCompute_TCPHealthCheck_ProxyHeader_None  = @"NONE";
NSString * const kGTLRCompute_TCPHealthCheck_ProxyHeader_ProxyV1 = @"PROXY_V1";

// GTLRCompute_VpnTunnel.status
NSString * const kGTLRCompute_VpnTunnel_Status_AllocatingResources = @"ALLOCATING_RESOURCES";
NSString * const kGTLRCompute_VpnTunnel_Status_AuthorizationError = @"AUTHORIZATION_ERROR";
NSString * const kGTLRCompute_VpnTunnel_Status_Deprovisioning  = @"DEPROVISIONING";
NSString * const kGTLRCompute_VpnTunnel_Status_Established     = @"ESTABLISHED";
NSString * const kGTLRCompute_VpnTunnel_Status_Failed          = @"FAILED";
NSString * const kGTLRCompute_VpnTunnel_Status_FirstHandshake  = @"FIRST_HANDSHAKE";
NSString * const kGTLRCompute_VpnTunnel_Status_NegotiationFailure = @"NEGOTIATION_FAILURE";
NSString * const kGTLRCompute_VpnTunnel_Status_NetworkError    = @"NETWORK_ERROR";
NSString * const kGTLRCompute_VpnTunnel_Status_NoIncomingPackets = @"NO_INCOMING_PACKETS";
NSString * const kGTLRCompute_VpnTunnel_Status_Provisioning    = @"PROVISIONING";
NSString * const kGTLRCompute_VpnTunnel_Status_Rejected        = @"REJECTED";
NSString * const kGTLRCompute_VpnTunnel_Status_WaitingForFullConfig = @"WAITING_FOR_FULL_CONFIG";

// GTLRCompute_VpnTunnelsScopedListWarning.code
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_CleanupFailed = @"CLEANUP_FAILED";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_DeprecatedResourceUsed = @"DEPRECATED_RESOURCE_USED";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_DiskSizeLargerThanImageSize = @"DISK_SIZE_LARGER_THAN_IMAGE_SIZE";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_FieldValueOverriden = @"FIELD_VALUE_OVERRIDEN";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_InjectedKernelsDeprecated = @"INJECTED_KERNELS_DEPRECATED";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopAddressNotAssigned = @"NEXT_HOP_ADDRESS_NOT_ASSIGNED";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopCannotIpForward = @"NEXT_HOP_CANNOT_IP_FORWARD";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotFound = @"NEXT_HOP_INSTANCE_NOT_FOUND";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopInstanceNotOnNetwork = @"NEXT_HOP_INSTANCE_NOT_ON_NETWORK";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NextHopNotRunning = @"NEXT_HOP_NOT_RUNNING";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NoResultsOnPage = @"NO_RESULTS_ON_PAGE";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_NotCriticalError = @"NOT_CRITICAL_ERROR";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_RequiredTosAgreement = @"REQUIRED_TOS_AGREEMENT";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_ResourceNotDeleted = @"RESOURCE_NOT_DELETED";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_SingleInstancePropertyTemplate = @"SINGLE_INSTANCE_PROPERTY_TEMPLATE";
NSString * const kGTLRCompute_VpnTunnelsScopedListWarning_Code_Unreachable = @"UNREACHABLE";

// GTLRCompute_Zone.status
NSString * const kGTLRCompute_Zone_Status_Down = @"DOWN";
NSString * const kGTLRCompute_Zone_Status_Up   = @"UP";

// ----------------------------------------------------------------------------
//
//   GTLRCompute_AccessConfig
//

@implementation GTLRCompute_AccessConfig
@dynamic kind, name, natIP, type;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Address
//

@implementation GTLRCompute_Address
@dynamic address, creationTimestamp, descriptionProperty, identifier, kind,
         name, region, selfLink, status, users;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"users" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressAggregatedList
//

@implementation GTLRCompute_AddressAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressAggregatedListItems
//

@implementation GTLRCompute_AddressAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_AddressesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressesScopedList
//

@implementation GTLRCompute_AddressesScopedList
@dynamic addresses, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"addresses" : [GTLRCompute_Address class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressesScopedListWarning
//

@implementation GTLRCompute_AddressesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_AddressesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressesScopedListWarningDataItem
//

@implementation GTLRCompute_AddressesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AddressList
//

@implementation GTLRCompute_AddressList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Address class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AttachedDisk
//

@implementation GTLRCompute_AttachedDisk
@dynamic autoDelete, boot, deviceName, diskEncryptionKey, index,
         initializeParams, interface, kind, licenses, mode, source, type;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"licenses" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AttachedDiskInitializeParams
//

@implementation GTLRCompute_AttachedDiskInitializeParams
@dynamic diskName, diskSizeGb, diskType, sourceImage, sourceImageEncryptionKey;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Autoscaler
//

@implementation GTLRCompute_Autoscaler
@dynamic autoscalingPolicy, creationTimestamp, descriptionProperty, identifier,
         kind, name, region, selfLink, target, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalerAggregatedList
//

@implementation GTLRCompute_AutoscalerAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalerAggregatedListItems
//

@implementation GTLRCompute_AutoscalerAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_AutoscalersScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalerList
//

@implementation GTLRCompute_AutoscalerList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Autoscaler class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalersScopedList
//

@implementation GTLRCompute_AutoscalersScopedList
@dynamic autoscalers, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"autoscalers" : [GTLRCompute_Autoscaler class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalersScopedListWarning
//

@implementation GTLRCompute_AutoscalersScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_AutoscalersScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalersScopedListWarningDataItem
//

@implementation GTLRCompute_AutoscalersScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalingPolicy
//

@implementation GTLRCompute_AutoscalingPolicy
@dynamic coolDownPeriodSec, cpuUtilization, customMetricUtilizations,
         loadBalancingUtilization, maxNumReplicas, minNumReplicas;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"customMetricUtilizations" : [GTLRCompute_AutoscalingPolicyCustomMetricUtilization class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalingPolicyCpuUtilization
//

@implementation GTLRCompute_AutoscalingPolicyCpuUtilization
@dynamic utilizationTarget;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalingPolicyCustomMetricUtilization
//

@implementation GTLRCompute_AutoscalingPolicyCustomMetricUtilization
@dynamic metric, utilizationTarget, utilizationTargetType;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_AutoscalingPolicyLoadBalancingUtilization
//

@implementation GTLRCompute_AutoscalingPolicyLoadBalancingUtilization
@dynamic utilizationTarget;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Backend
//

@implementation GTLRCompute_Backend
@dynamic balancingMode, capacityScaler, descriptionProperty, group,
         maxConnections, maxConnectionsPerInstance, maxRate, maxRatePerInstance,
         maxUtilization;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_BackendService
//

@implementation GTLRCompute_BackendService
@dynamic affinityCookieTtlSec, backends, connectionDraining, creationTimestamp,
         descriptionProperty, enableCDN, fingerprint, healthChecks, identifier,
         kind, name, port, portName, protocol, region, selfLink,
         sessionAffinity, timeoutSec;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"backends" : [GTLRCompute_Backend class],
    @"healthChecks" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_BackendServiceGroupHealth
//

@implementation GTLRCompute_BackendServiceGroupHealth
@dynamic healthStatus, kind;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthStatus" : [GTLRCompute_HealthStatus class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_BackendServiceList
//

@implementation GTLRCompute_BackendServiceList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_BackendService class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_CacheInvalidationRule
//

@implementation GTLRCompute_CacheInvalidationRule
@dynamic path;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ConnectionDraining
//

@implementation GTLRCompute_ConnectionDraining
@dynamic drainingTimeoutSec;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_CustomerEncryptionKey
//

@implementation GTLRCompute_CustomerEncryptionKey
@dynamic rawKey, sha256;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_CustomerEncryptionKeyProtectedDisk
//

@implementation GTLRCompute_CustomerEncryptionKeyProtectedDisk
@dynamic diskEncryptionKey, source;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DeprecationStatus
//

@implementation GTLRCompute_DeprecationStatus
@dynamic deleted, deprecated, obsolete, replacement, state;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Disk
//

@implementation GTLRCompute_Disk
@dynamic creationTimestamp, descriptionProperty, diskEncryptionKey, identifier,
         kind, lastAttachTimestamp, lastDetachTimestamp, licenses, name,
         options, selfLink, sizeGb, sourceImage, sourceImageEncryptionKey,
         sourceImageId, sourceSnapshot, sourceSnapshotEncryptionKey,
         sourceSnapshotId, status, type, users, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"licenses" : [NSString class],
    @"users" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskAggregatedList
//

@implementation GTLRCompute_DiskAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskAggregatedListItems
//

@implementation GTLRCompute_DiskAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_DisksScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskList
//

@implementation GTLRCompute_DiskList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Disk class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskMoveRequest
//

@implementation GTLRCompute_DiskMoveRequest
@dynamic destinationZone, targetDisk;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DisksResizeRequest
//

@implementation GTLRCompute_DisksResizeRequest
@dynamic sizeGb;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DisksScopedList
//

@implementation GTLRCompute_DisksScopedList
@dynamic disks, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"disks" : [GTLRCompute_Disk class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DisksScopedListWarning
//

@implementation GTLRCompute_DisksScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_DisksScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DisksScopedListWarningDataItem
//

@implementation GTLRCompute_DisksScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskType
//

@implementation GTLRCompute_DiskType
@dynamic creationTimestamp, defaultDiskSizeGb, deprecated, descriptionProperty,
         identifier, kind, name, selfLink, validDiskSize, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypeAggregatedList
//

@implementation GTLRCompute_DiskTypeAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypeAggregatedListItems
//

@implementation GTLRCompute_DiskTypeAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_DiskTypesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypeList
//

@implementation GTLRCompute_DiskTypeList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_DiskType class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypesScopedList
//

@implementation GTLRCompute_DiskTypesScopedList
@dynamic diskTypes, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"diskTypes" : [GTLRCompute_DiskType class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypesScopedListWarning
//

@implementation GTLRCompute_DiskTypesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_DiskTypesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_DiskTypesScopedListWarningDataItem
//

@implementation GTLRCompute_DiskTypesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Firewall
//

@implementation GTLRCompute_Firewall
@dynamic allowed, creationTimestamp, descriptionProperty, identifier, kind,
         name, network, selfLink, sourceRanges, sourceTags, targetTags;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"allowed" : [GTLRCompute_FirewallAllowedItem class],
    @"sourceRanges" : [NSString class],
    @"sourceTags" : [NSString class],
    @"targetTags" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_FirewallAllowedItem
//

@implementation GTLRCompute_FirewallAllowedItem
@dynamic IPProtocol, ports;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"ports" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_FirewallList
//

@implementation GTLRCompute_FirewallList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Firewall class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRule
//

@implementation GTLRCompute_ForwardingRule
@dynamic creationTimestamp, descriptionProperty, identifier, IPAddress,
         IPProtocol, kind, name, portRange, region, selfLink, target;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRuleAggregatedList
//

@implementation GTLRCompute_ForwardingRuleAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRuleAggregatedListItems
//

@implementation GTLRCompute_ForwardingRuleAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_ForwardingRulesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRuleList
//

@implementation GTLRCompute_ForwardingRuleList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_ForwardingRule class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRulesScopedList
//

@implementation GTLRCompute_ForwardingRulesScopedList
@dynamic forwardingRules, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"forwardingRules" : [GTLRCompute_ForwardingRule class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRulesScopedListWarning
//

@implementation GTLRCompute_ForwardingRulesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_ForwardingRulesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ForwardingRulesScopedListWarningDataItem
//

@implementation GTLRCompute_ForwardingRulesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HealthCheck
//

@implementation GTLRCompute_HealthCheck
@dynamic checkIntervalSec, creationTimestamp, descriptionProperty,
         healthyThreshold, http2HealthCheck, httpHealthCheck, httpsHealthCheck,
         identifier, kind, name, selfLink, sslHealthCheck, tcpHealthCheck,
         timeoutSec, type, unhealthyThreshold;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HealthCheckList
//

@implementation GTLRCompute_HealthCheckList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_HealthCheck class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HealthCheckReference
//

@implementation GTLRCompute_HealthCheckReference
@dynamic healthCheck;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HealthStatus
//

@implementation GTLRCompute_HealthStatus
@dynamic healthState, instance, ipAddress, port;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HostRule
//

@implementation GTLRCompute_HostRule
@dynamic descriptionProperty, hosts, pathMatcher;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"hosts" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HTTP2HealthCheck
//

@implementation GTLRCompute_HTTP2HealthCheck
@dynamic host, port, portName, proxyHeader, requestPath;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HTTPHealthCheck
//

@implementation GTLRCompute_HTTPHealthCheck
@dynamic host, port, portName, proxyHeader, requestPath;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HttpHealthCheck
//

@implementation GTLRCompute_HttpHealthCheck
@dynamic checkIntervalSec, creationTimestamp, descriptionProperty,
         healthyThreshold, host, identifier, kind, name, port, requestPath,
         selfLink, timeoutSec, unhealthyThreshold;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HttpHealthCheckList
//

@implementation GTLRCompute_HttpHealthCheckList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_HttpHealthCheck class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HttpsHealthCheck
//

@implementation GTLRCompute_HttpsHealthCheck
@dynamic checkIntervalSec, creationTimestamp, descriptionProperty,
         healthyThreshold, host, identifier, kind, name, port, requestPath,
         selfLink, timeoutSec, unhealthyThreshold;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HTTPSHealthCheck
//

@implementation GTLRCompute_HTTPSHealthCheck
@dynamic host, port, portName, proxyHeader, requestPath;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_HttpsHealthCheckList
//

@implementation GTLRCompute_HttpsHealthCheckList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_HttpsHealthCheck class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Image
//

@implementation GTLRCompute_Image
@dynamic archiveSizeBytes, creationTimestamp, deprecated, descriptionProperty,
         diskSizeGb, family, identifier, imageEncryptionKey, kind, licenses,
         name, rawDisk, selfLink, sourceDisk, sourceDiskEncryptionKey,
         sourceDiskId, sourceType, status;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"licenses" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ImageRawDisk
//

@implementation GTLRCompute_ImageRawDisk
@dynamic containerType, sha1Checksum, source;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ImageList
//

@implementation GTLRCompute_ImageList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Image class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Instance
//

@implementation GTLRCompute_Instance
@dynamic canIpForward, cpuPlatform, creationTimestamp, descriptionProperty,
         disks, identifier, kind, machineType, metadata, name,
         networkInterfaces, scheduling, selfLink, serviceAccounts, status,
         statusMessage, tags, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"disks" : [GTLRCompute_AttachedDisk class],
    @"networkInterfaces" : [GTLRCompute_NetworkInterface class],
    @"serviceAccounts" : [GTLRCompute_ServiceAccount class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceAggregatedList
//

@implementation GTLRCompute_InstanceAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceAggregatedListItems
//

@implementation GTLRCompute_InstanceAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_InstancesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroup
//

@implementation GTLRCompute_InstanceGroup
@dynamic creationTimestamp, descriptionProperty, fingerprint, identifier, kind,
         name, namedPorts, network, region, selfLink, size, subnetwork,
         zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"namedPorts" : [GTLRCompute_NamedPort class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupAggregatedList
//

@implementation GTLRCompute_InstanceGroupAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupAggregatedListItems
//

@implementation GTLRCompute_InstanceGroupAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_InstanceGroupsScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupList
//

@implementation GTLRCompute_InstanceGroupList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_InstanceGroup class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManager
//

@implementation GTLRCompute_InstanceGroupManager
@dynamic baseInstanceName, creationTimestamp, currentActions,
         descriptionProperty, fingerprint, identifier, instanceGroup,
         instanceTemplate, kind, name, namedPorts, region, selfLink,
         targetPools, targetSize, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"namedPorts" : [GTLRCompute_NamedPort class],
    @"targetPools" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagerActionsSummary
//

@implementation GTLRCompute_InstanceGroupManagerActionsSummary
@dynamic abandoning, creating, creatingWithoutRetries, deleting, none,
         recreating, refreshing, restarting;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagerAggregatedList
//

@implementation GTLRCompute_InstanceGroupManagerAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagerAggregatedListItems
//

@implementation GTLRCompute_InstanceGroupManagerAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_InstanceGroupManagersScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagerList
//

@implementation GTLRCompute_InstanceGroupManagerList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_InstanceGroupManager class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersAbandonInstancesRequest
//

@implementation GTLRCompute_InstanceGroupManagersAbandonInstancesRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
//

@implementation GTLRCompute_InstanceGroupManagersDeleteInstancesRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersListManagedInstancesResponse
//

@implementation GTLRCompute_InstanceGroupManagersListManagedInstancesResponse
@dynamic managedInstances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"managedInstances" : [GTLRCompute_ManagedInstance class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersRecreateInstancesRequest
//

@implementation GTLRCompute_InstanceGroupManagersRecreateInstancesRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersScopedList
//

@implementation GTLRCompute_InstanceGroupManagersScopedList
@dynamic instanceGroupManagers, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instanceGroupManagers" : [GTLRCompute_InstanceGroupManager class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersScopedListWarning
//

@implementation GTLRCompute_InstanceGroupManagersScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_InstanceGroupManagersScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersScopedListWarningDataItem
//

@implementation GTLRCompute_InstanceGroupManagersScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest
//

@implementation GTLRCompute_InstanceGroupManagersSetInstanceTemplateRequest
@dynamic instanceTemplate;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
//

@implementation GTLRCompute_InstanceGroupManagersSetTargetPoolsRequest
@dynamic fingerprint, targetPools;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"targetPools" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsAddInstancesRequest
//

@implementation GTLRCompute_InstanceGroupsAddInstancesRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [GTLRCompute_InstanceReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsListInstances
//

@implementation GTLRCompute_InstanceGroupsListInstances
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_InstanceWithNamedPorts class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsListInstancesRequest
//

@implementation GTLRCompute_InstanceGroupsListInstancesRequest
@dynamic instanceState;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsRemoveInstancesRequest
//

@implementation GTLRCompute_InstanceGroupsRemoveInstancesRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [GTLRCompute_InstanceReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsScopedList
//

@implementation GTLRCompute_InstanceGroupsScopedList
@dynamic instanceGroups, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instanceGroups" : [GTLRCompute_InstanceGroup class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsScopedListWarning
//

@implementation GTLRCompute_InstanceGroupsScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_InstanceGroupsScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsScopedListWarningDataItem
//

@implementation GTLRCompute_InstanceGroupsScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceGroupsSetNamedPortsRequest
//

@implementation GTLRCompute_InstanceGroupsSetNamedPortsRequest
@dynamic fingerprint, namedPorts;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"namedPorts" : [GTLRCompute_NamedPort class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceList
//

@implementation GTLRCompute_InstanceList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Instance class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceMoveRequest
//

@implementation GTLRCompute_InstanceMoveRequest
@dynamic destinationZone, targetInstance;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceProperties
//

@implementation GTLRCompute_InstanceProperties
@dynamic canIpForward, descriptionProperty, disks, machineType, metadata,
         networkInterfaces, scheduling, serviceAccounts, tags;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"disks" : [GTLRCompute_AttachedDisk class],
    @"networkInterfaces" : [GTLRCompute_NetworkInterface class],
    @"serviceAccounts" : [GTLRCompute_ServiceAccount class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceReference
//

@implementation GTLRCompute_InstanceReference
@dynamic instance;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstancesScopedList
//

@implementation GTLRCompute_InstancesScopedList
@dynamic instances, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [GTLRCompute_Instance class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstancesScopedListWarning
//

@implementation GTLRCompute_InstancesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_InstancesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstancesScopedListWarningDataItem
//

@implementation GTLRCompute_InstancesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstancesSetMachineTypeRequest
//

@implementation GTLRCompute_InstancesSetMachineTypeRequest
@dynamic machineType;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstancesStartWithEncryptionKeyRequest
//

@implementation GTLRCompute_InstancesStartWithEncryptionKeyRequest
@dynamic disks;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"disks" : [GTLRCompute_CustomerEncryptionKeyProtectedDisk class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceTemplate
//

@implementation GTLRCompute_InstanceTemplate
@dynamic creationTimestamp, descriptionProperty, identifier, kind, name,
         properties, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceTemplateList
//

@implementation GTLRCompute_InstanceTemplateList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_InstanceTemplate class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_InstanceWithNamedPorts
//

@implementation GTLRCompute_InstanceWithNamedPorts
@dynamic instance, namedPorts, status;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"namedPorts" : [GTLRCompute_NamedPort class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_License
//

@implementation GTLRCompute_License
@dynamic chargesUseFee, kind, name, selfLink;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineType
//

@implementation GTLRCompute_MachineType
@dynamic creationTimestamp, deprecated, descriptionProperty, guestCpus,
         identifier, imageSpaceGb, isSharedCpu, kind, maximumPersistentDisks,
         maximumPersistentDisksSizeGb, memoryMb, name, scratchDisks, selfLink,
         zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"scratchDisks" : [GTLRCompute_MachineTypeScratchDisksItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypeScratchDisksItem
//

@implementation GTLRCompute_MachineTypeScratchDisksItem
@dynamic diskGb;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypeAggregatedList
//

@implementation GTLRCompute_MachineTypeAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypeAggregatedListItems
//

@implementation GTLRCompute_MachineTypeAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_MachineTypesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypeList
//

@implementation GTLRCompute_MachineTypeList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_MachineType class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypesScopedList
//

@implementation GTLRCompute_MachineTypesScopedList
@dynamic machineTypes, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"machineTypes" : [GTLRCompute_MachineType class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypesScopedListWarning
//

@implementation GTLRCompute_MachineTypesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_MachineTypesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MachineTypesScopedListWarningDataItem
//

@implementation GTLRCompute_MachineTypesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ManagedInstance
//

@implementation GTLRCompute_ManagedInstance
@dynamic currentAction, identifier, instance, instanceStatus, lastAttempt;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ManagedInstanceLastAttempt
//

@implementation GTLRCompute_ManagedInstanceLastAttempt
@dynamic errors;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ManagedInstanceLastAttemptErrors
//

@implementation GTLRCompute_ManagedInstanceLastAttemptErrors
@dynamic errors;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"errors" : [GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem
//

@implementation GTLRCompute_ManagedInstanceLastAttemptErrorsErrorsItem
@dynamic code, location, message;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Metadata
//

@implementation GTLRCompute_Metadata
@dynamic fingerprint, items, kind;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_MetadataItemsItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_MetadataItemsItem
//

@implementation GTLRCompute_MetadataItemsItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_NamedPort
//

@implementation GTLRCompute_NamedPort
@dynamic name, port;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Network
//

@implementation GTLRCompute_Network
@dynamic autoCreateSubnetworks, creationTimestamp, descriptionProperty,
         gatewayIPv4, identifier, IPv4Range, kind, name, selfLink, subnetworks;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"subnetworks" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_NetworkInterface
//

@implementation GTLRCompute_NetworkInterface
@dynamic accessConfigs, name, network, networkIP, subnetwork;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"accessConfigs" : [GTLRCompute_AccessConfig class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_NetworkList
//

@implementation GTLRCompute_NetworkList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Network class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Operation
//

@implementation GTLRCompute_Operation
@dynamic clientOperationId, creationTimestamp, descriptionProperty, endTime,
         error, httpErrorMessage, httpErrorStatusCode, identifier, insertTime,
         kind, name, operationType, progress, region, selfLink, startTime,
         status, statusMessage, targetId, targetLink, user, warnings,
         zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"warnings" : [GTLRCompute_OperationWarningsItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationError
//

@implementation GTLRCompute_OperationError
@dynamic errors;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"errors" : [GTLRCompute_OperationErrorErrorsItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationWarningsItem
//

@implementation GTLRCompute_OperationWarningsItem
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_OperationWarningsItemDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationErrorErrorsItem
//

@implementation GTLRCompute_OperationErrorErrorsItem
@dynamic code, location, message;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationWarningsItemDataItem
//

@implementation GTLRCompute_OperationWarningsItemDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationAggregatedList
//

@implementation GTLRCompute_OperationAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationAggregatedListItems
//

@implementation GTLRCompute_OperationAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_OperationsScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationList
//

@implementation GTLRCompute_OperationList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Operation class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationsScopedList
//

@implementation GTLRCompute_OperationsScopedList
@dynamic operations, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"operations" : [GTLRCompute_Operation class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationsScopedListWarning
//

@implementation GTLRCompute_OperationsScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_OperationsScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_OperationsScopedListWarningDataItem
//

@implementation GTLRCompute_OperationsScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_PathMatcher
//

@implementation GTLRCompute_PathMatcher
@dynamic defaultService, descriptionProperty, name, pathRules;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"pathRules" : [GTLRCompute_PathRule class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_PathRule
//

@implementation GTLRCompute_PathRule
@dynamic paths, service;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"paths" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Project
//

@implementation GTLRCompute_Project
@dynamic commonInstanceMetadata, creationTimestamp, defaultServiceAccount,
         descriptionProperty, enabledFeatures, identifier, kind, name, quotas,
         selfLink, usageExportLocation;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"enabledFeatures" : [NSString class],
    @"quotas" : [GTLRCompute_Quota class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Quota
//

@implementation GTLRCompute_Quota
@dynamic limit, metric, usage;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Region
//

@implementation GTLRCompute_Region
@dynamic creationTimestamp, deprecated, descriptionProperty, identifier, kind,
         name, quotas, selfLink, status, zones;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"quotas" : [GTLRCompute_Quota class],
    @"zones" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RegionList
//

@implementation GTLRCompute_RegionList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Region class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ResourceGroupReference
//

@implementation GTLRCompute_ResourceGroupReference
@dynamic group;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Route
//

@implementation GTLRCompute_Route
@dynamic creationTimestamp, descriptionProperty, destRange, identifier, kind,
         name, network, nextHopGateway, nextHopInstance, nextHopIp,
         nextHopNetwork, nextHopVpnTunnel, priority, selfLink, tags, warnings;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"tags" : [NSString class],
    @"warnings" : [GTLRCompute_RouteWarningsItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouteWarningsItem
//

@implementation GTLRCompute_RouteWarningsItem
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_RouteWarningsItemDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouteWarningsItemDataItem
//

@implementation GTLRCompute_RouteWarningsItemDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouteList
//

@implementation GTLRCompute_RouteList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Route class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Router
//

@implementation GTLRCompute_Router
@dynamic bgp, bgpPeers, creationTimestamp, descriptionProperty, identifier,
         interfaces, kind, name, network, region, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"bgpPeers" : [GTLRCompute_RouterBgpPeer class],
    @"interfaces" : [GTLRCompute_RouterInterface class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterAggregatedList
//

@implementation GTLRCompute_RouterAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterAggregatedListItems
//

@implementation GTLRCompute_RouterAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_RoutersScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterBgp
//

@implementation GTLRCompute_RouterBgp
@dynamic asn;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterBgpPeer
//

@implementation GTLRCompute_RouterBgpPeer
@dynamic advertisedRoutePriority, interfaceName, ipAddress, name, peerAsn,
         peerIpAddress;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterInterface
//

@implementation GTLRCompute_RouterInterface
@dynamic ipRange, linkedVpnTunnel, name;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterList
//

@implementation GTLRCompute_RouterList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Router class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RoutersPreviewResponse
//

@implementation GTLRCompute_RoutersPreviewResponse
@dynamic resource;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RoutersScopedList
//

@implementation GTLRCompute_RoutersScopedList
@dynamic routers, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"routers" : [GTLRCompute_Router class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RoutersScopedListWarning
//

@implementation GTLRCompute_RoutersScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_RoutersScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RoutersScopedListWarningDataItem
//

@implementation GTLRCompute_RoutersScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterStatus
//

@implementation GTLRCompute_RouterStatus
@dynamic bestRoutes, bgpPeerStatus, network;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"bestRoutes" : [GTLRCompute_Route class],
    @"bgpPeerStatus" : [GTLRCompute_RouterStatusBgpPeerStatus class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterStatusBgpPeerStatus
//

@implementation GTLRCompute_RouterStatusBgpPeerStatus
@dynamic advertisedRoutes, ipAddress, linkedVpnTunnel, name, numLearnedRoutes,
         peerIpAddress, state, status, uptime, uptimeSeconds;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"advertisedRoutes" : [GTLRCompute_Route class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_RouterStatusResponse
//

@implementation GTLRCompute_RouterStatusResponse
@dynamic kind, result;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Scheduling
//

@implementation GTLRCompute_Scheduling
@dynamic automaticRestart, onHostMaintenance, preemptible;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SerialPortOutput
//

@implementation GTLRCompute_SerialPortOutput
@dynamic contents, kind, selfLink;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ServiceAccount
//

@implementation GTLRCompute_ServiceAccount
@dynamic email, scopes;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"scopes" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Snapshot
//

@implementation GTLRCompute_Snapshot
@dynamic creationTimestamp, descriptionProperty, diskSizeGb, identifier, kind,
         licenses, name, selfLink, snapshotEncryptionKey, sourceDisk,
         sourceDiskEncryptionKey, sourceDiskId, status, storageBytes,
         storageBytesStatus;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"licenses" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SnapshotList
//

@implementation GTLRCompute_SnapshotList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Snapshot class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SslCertificate
//

@implementation GTLRCompute_SslCertificate
@dynamic certificate, creationTimestamp, descriptionProperty, identifier, kind,
         name, privateKey, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SslCertificateList
//

@implementation GTLRCompute_SslCertificateList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_SslCertificate class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SSLHealthCheck
//

@implementation GTLRCompute_SSLHealthCheck
@dynamic port, portName, proxyHeader, request, response;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Subnetwork
//

@implementation GTLRCompute_Subnetwork
@dynamic creationTimestamp, descriptionProperty, gatewayAddress, identifier,
         ipCidrRange, kind, name, network, region, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworkAggregatedList
//

@implementation GTLRCompute_SubnetworkAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworkAggregatedListItems
//

@implementation GTLRCompute_SubnetworkAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_SubnetworksScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworkList
//

@implementation GTLRCompute_SubnetworkList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Subnetwork class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworksScopedList
//

@implementation GTLRCompute_SubnetworksScopedList
@dynamic subnetworks, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"subnetworks" : [GTLRCompute_Subnetwork class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworksScopedListWarning
//

@implementation GTLRCompute_SubnetworksScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_SubnetworksScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_SubnetworksScopedListWarningDataItem
//

@implementation GTLRCompute_SubnetworksScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Tags
//

@implementation GTLRCompute_Tags
@dynamic fingerprint, items;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetHttpProxy
//

@implementation GTLRCompute_TargetHttpProxy
@dynamic creationTimestamp, descriptionProperty, identifier, kind, name,
         selfLink, urlMap;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetHttpProxyList
//

@implementation GTLRCompute_TargetHttpProxyList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetHttpProxy class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
//

@implementation GTLRCompute_TargetHttpsProxiesSetSslCertificatesRequest
@dynamic sslCertificates;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"sslCertificates" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetHttpsProxy
//

@implementation GTLRCompute_TargetHttpsProxy
@dynamic creationTimestamp, descriptionProperty, identifier, kind, name,
         selfLink, sslCertificates, urlMap;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"sslCertificates" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetHttpsProxyList
//

@implementation GTLRCompute_TargetHttpsProxyList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetHttpsProxy class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstance
//

@implementation GTLRCompute_TargetInstance
@dynamic creationTimestamp, descriptionProperty, identifier, instance, kind,
         name, natPolicy, selfLink, zoneProperty;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id",
    @"zoneProperty" : @"zone"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstanceAggregatedList
//

@implementation GTLRCompute_TargetInstanceAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstanceAggregatedListItems
//

@implementation GTLRCompute_TargetInstanceAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_TargetInstancesScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstanceList
//

@implementation GTLRCompute_TargetInstanceList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetInstance class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstancesScopedList
//

@implementation GTLRCompute_TargetInstancesScopedList
@dynamic targetInstances, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"targetInstances" : [GTLRCompute_TargetInstance class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstancesScopedListWarning
//

@implementation GTLRCompute_TargetInstancesScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_TargetInstancesScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetInstancesScopedListWarningDataItem
//

@implementation GTLRCompute_TargetInstancesScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPool
//

@implementation GTLRCompute_TargetPool
@dynamic backupPool, creationTimestamp, descriptionProperty, failoverRatio,
         healthChecks, identifier, instances, kind, name, region, selfLink,
         sessionAffinity;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthChecks" : [NSString class],
    @"instances" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolAggregatedList
//

@implementation GTLRCompute_TargetPoolAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolAggregatedListItems
//

@implementation GTLRCompute_TargetPoolAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_TargetPoolsScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolInstanceHealth
//

@implementation GTLRCompute_TargetPoolInstanceHealth
@dynamic healthStatus, kind;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthStatus" : [GTLRCompute_HealthStatus class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolList
//

@implementation GTLRCompute_TargetPoolList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetPool class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsAddHealthCheckRequest
//

@implementation GTLRCompute_TargetPoolsAddHealthCheckRequest
@dynamic healthChecks;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthChecks" : [GTLRCompute_HealthCheckReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsAddInstanceRequest
//

@implementation GTLRCompute_TargetPoolsAddInstanceRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [GTLRCompute_InstanceReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsRemoveHealthCheckRequest
//

@implementation GTLRCompute_TargetPoolsRemoveHealthCheckRequest
@dynamic healthChecks;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"healthChecks" : [GTLRCompute_HealthCheckReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsRemoveInstanceRequest
//

@implementation GTLRCompute_TargetPoolsRemoveInstanceRequest
@dynamic instances;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"instances" : [GTLRCompute_InstanceReference class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsScopedList
//

@implementation GTLRCompute_TargetPoolsScopedList
@dynamic targetPools, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"targetPools" : [GTLRCompute_TargetPool class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsScopedListWarning
//

@implementation GTLRCompute_TargetPoolsScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_TargetPoolsScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetPoolsScopedListWarningDataItem
//

@implementation GTLRCompute_TargetPoolsScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetReference
//

@implementation GTLRCompute_TargetReference
@dynamic target;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetSslProxiesSetBackendServiceRequest
//

@implementation GTLRCompute_TargetSslProxiesSetBackendServiceRequest
@dynamic service;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetSslProxiesSetProxyHeaderRequest
//

@implementation GTLRCompute_TargetSslProxiesSetProxyHeaderRequest
@dynamic proxyHeader;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetSslProxiesSetSslCertificatesRequest
//

@implementation GTLRCompute_TargetSslProxiesSetSslCertificatesRequest
@dynamic sslCertificates;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"sslCertificates" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetSslProxy
//

@implementation GTLRCompute_TargetSslProxy
@dynamic creationTimestamp, descriptionProperty, identifier, kind, name,
         proxyHeader, selfLink, service, sslCertificates;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"sslCertificates" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetSslProxyList
//

@implementation GTLRCompute_TargetSslProxyList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetSslProxy class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGateway
//

@implementation GTLRCompute_TargetVpnGateway
@dynamic creationTimestamp, descriptionProperty, forwardingRules, identifier,
         kind, name, network, region, selfLink, status, tunnels;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"forwardingRules" : [NSString class],
    @"tunnels" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewayAggregatedList
//

@implementation GTLRCompute_TargetVpnGatewayAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewayAggregatedListItems
//

@implementation GTLRCompute_TargetVpnGatewayAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_TargetVpnGatewaysScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewayList
//

@implementation GTLRCompute_TargetVpnGatewayList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_TargetVpnGateway class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewaysScopedList
//

@implementation GTLRCompute_TargetVpnGatewaysScopedList
@dynamic targetVpnGateways, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"targetVpnGateways" : [GTLRCompute_TargetVpnGateway class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewaysScopedListWarning
//

@implementation GTLRCompute_TargetVpnGatewaysScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem
//

@implementation GTLRCompute_TargetVpnGatewaysScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TCPHealthCheck
//

@implementation GTLRCompute_TCPHealthCheck
@dynamic port, portName, proxyHeader, request, response;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_TestFailure
//

@implementation GTLRCompute_TestFailure
@dynamic actualService, expectedService, host, path;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMap
//

@implementation GTLRCompute_UrlMap
@dynamic creationTimestamp, defaultService, descriptionProperty, fingerprint,
         hostRules, identifier, kind, name, pathMatchers, selfLink, tests;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"hostRules" : [GTLRCompute_HostRule class],
    @"pathMatchers" : [GTLRCompute_PathMatcher class],
    @"tests" : [GTLRCompute_UrlMapTest class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapList
//

@implementation GTLRCompute_UrlMapList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_UrlMap class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapReference
//

@implementation GTLRCompute_UrlMapReference
@dynamic urlMap;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapsValidateRequest
//

@implementation GTLRCompute_UrlMapsValidateRequest
@dynamic resource;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapsValidateResponse
//

@implementation GTLRCompute_UrlMapsValidateResponse
@dynamic result;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapTest
//

@implementation GTLRCompute_UrlMapTest
@dynamic descriptionProperty, host, path, service;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"descriptionProperty" : @"description" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UrlMapValidationResult
//

@implementation GTLRCompute_UrlMapValidationResult
@dynamic loadErrors, loadSucceeded, testFailures, testPassed;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"loadErrors" : [NSString class],
    @"testFailures" : [GTLRCompute_TestFailure class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_UsageExportLocation
//

@implementation GTLRCompute_UsageExportLocation
@dynamic bucketName, reportNamePrefix;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnel
//

@implementation GTLRCompute_VpnTunnel
@dynamic creationTimestamp, descriptionProperty, detailedStatus, identifier,
         ikeVersion, kind, localTrafficSelector, name, peerIp, region,
         remoteTrafficSelector, router, selfLink, sharedSecret,
         sharedSecretHash, status, targetVpnGateway;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"localTrafficSelector" : [NSString class],
    @"remoteTrafficSelector" : [NSString class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelAggregatedList
//

@implementation GTLRCompute_VpnTunnelAggregatedList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelAggregatedListItems
//

@implementation GTLRCompute_VpnTunnelAggregatedListItems

+ (Class)classForAdditionalProperties {
  return [GTLRCompute_VpnTunnelsScopedList class];
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelList
//

@implementation GTLRCompute_VpnTunnelList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_VpnTunnel class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelsScopedList
//

@implementation GTLRCompute_VpnTunnelsScopedList
@dynamic vpnTunnels, warning;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"vpnTunnels" : [GTLRCompute_VpnTunnel class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelsScopedListWarning
//

@implementation GTLRCompute_VpnTunnelsScopedListWarning
@dynamic code, data, message;

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"data" : [GTLRCompute_VpnTunnelsScopedListWarningDataItem class]
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_VpnTunnelsScopedListWarningDataItem
//

@implementation GTLRCompute_VpnTunnelsScopedListWarningDataItem
@dynamic key, value;
@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_Zone
//

@implementation GTLRCompute_Zone
@dynamic creationTimestamp, deprecated, descriptionProperty, identifier, kind,
         name, region, selfLink, status;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  NSDictionary<NSString *, NSString *> *map = @{
    @"descriptionProperty" : @"description",
    @"identifier" : @"id"
  };
  return map;
}

@end


// ----------------------------------------------------------------------------
//
//   GTLRCompute_ZoneList
//

@implementation GTLRCompute_ZoneList
@dynamic identifier, items, kind, nextPageToken, selfLink;

+ (NSDictionary<NSString *, NSString *> *)propertyToJSONKeyMap {
  return @{ @"identifier" : @"id" };
}

+ (NSDictionary<NSString *, Class> *)arrayPropertyToClassMap {
  NSDictionary<NSString *, Class> *map = @{
    @"items" : [GTLRCompute_Zone class]
  };
  return map;
}

@end
