//
//  SGGeneration+Argo.swift
//  ServiceGenerator
//
//  Created by Douglas Beal on 7/9/16.
//
//

import Foundation


public let header = [
           "// generated by ServiceGenerator",
           "import Argo"]

public let indentString = "    "
func indent(level: Int = 0) -> String {
    var string = ""
    for _ in 0..<level {
        string = string + indentString
    }
    return string
}

struct SchemaSwiftWrapper: CustomStringConvertible {
    private let schema: GTLRDiscovery_JsonSchema
    //private var _type: SGTypeInfo? = nil
    // var type: SGTypeInfo {
    //     if _type == nil {
    //         _type = LookupTypeInfo(schema.type)
    //     }
    //     return _type!
    // }
    var type: String { return schema.type! }
    
    var description: String {
        return "type \(schema.type), format \(schema.format)"
    }
    init( schema: GTLRDiscovery_JsonSchema ) {
        self.schema = schema
    }


}
public extension SGGenerator {

    public func objectsCodingArgoSource() -> String {
        var parts: Array<String> = header
        var classParts: Array<String> = []
        var curry = Set<UInt32>()
        for schema in self.api.sg_topLevelObjectSchemas  {
            guard let schema = schema as? GTLRDiscovery_JsonSchema else { fatalError() }
            let (objectClassStr,curryArgSet) = self.generateObjectArgoExtension(schema,
                                                                   forMode:kGenerateImplementation)
            classParts.append(objectClassStr)
            curry = curry.union(curryArgSet)
            for subSchema in schema.sg_childObjectSchemas  {
                guard let subSchema = subSchema as? GTLRDiscovery_JsonSchema else { fatalError() }
                let (subObjectClassStr,currySubArgSet) = self.generateObjectArgoExtension(subSchema,
                                                                   forMode:kGenerateImplementation)
                classParts.append(subObjectClassStr)
                curry = curry.union(currySubArgSet)
            }

        }
        var customCurry: Array<String> = []
        let offset = UInt32(UnicodeScalar("A").value)
        let digitSize = UInt32(UnicodeScalar("Z").value) - offset
        for arity in curry.sort() {
            guard arity > 1 else { continue }
            let types: Array<String> = Range<UInt32>(0..<arity).map {
                (position) in
                var string = ""
                if position > digitSize {
                    for digit in (1...(arity/digitSize)).reverse() {
                        let div = UInt32(digitSize*digit)
                        let ch = position/div
                        string += String(Character(UnicodeScalar(offset + ch)))
                    }
                }
                string += String(Character(UnicodeScalar(offset + (position%digitSize))))
                return string
            }
            let curryFunc = "func curry<" + types.joinWithSeparator(",") +
                ">(function: (" + types.joinWithSeparator(",") +
                ")) ->"
            customCurry.append(curryFunc)
            
        }
        parts.append(customCurry.joinWithSeparator("\n"))
        // Two blank lines between classes.
        parts.append(classParts.joinWithSeparator("\n\n"))
        return parts.joinWithSeparator("\n")
    }

    public func generateObjectArgoExtension(schema: GTLRDiscovery_JsonSchema,
                                             forMode mode: GeneratorMode )
    -> (body: String, curry: Set<UInt32>) {
        var body = Array<String>()
        var curryArgSet = Set<UInt32>()
        let locator = "\(#file):\(#function):\(#line):\(#column)"
        let schemaClassName = schema.sg_objcClassName
        let `extension` = "extension \(schemaClassName): Decodable { // \(locator)"
        let extensionOpen = indent(0) + `extension`
        let extensionClose = indent(0) + "} //" + `extension`
        body.append(extensionOpen)
        let decodeOpen = indent(1) + "static func decode (json: Argo.JSON) -> Decoded<\(schemaClassName)> {"
        let chunkSize = 2
        var chunkIndex = 0
        body.append(decodeOpen)        
        if let properties = schema.properties?.additionalProperties() {
            let curry = indent(2) + "let part\(chunkIndex) = Curry.curry(\(schemaClassName).init)"
            chunkIndex += 1
            body.append(curry)
            var count = UInt32(0)
            for (index,(name,schema)) in (properties.sort { $0.0 < $1.0 } ).enumerate() {
                guard let schema = schema as? GTLRDiscovery_JsonSchema else { fatalError() }
                let op = (index == 0) ? "<^>": "<*>"
                let property = SchemaSwiftWrapper(schema: schema.sg_resolvedSchema)
                if index > 0 && index % chunkSize == 0 {
                    body.append(indent(2) +
                                  "let part\(chunkIndex) = part\(chunkIndex-1)")
                    chunkIndex += 1
                }
                let isArray = property.type == "array"
                let isOptional = true
                var deop = isArray ? "<||" : "<|"
                if isOptional {
                    deop += "?"
                }
                guard index >= 0 else { fatalError() }
                count = UInt32(index)
                body.append(indent(3) + "\(op) json \(deop) \"\(name)\"")
            }
            curryArgSet.insert(count)
            body.append(indent(2) +
                          "return part\(chunkIndex-1)")
        }

        let decodeClose = indent(1) + "} // decode"
        body.append(decodeClose)

        body.append(extensionClose)
        return (body: body.joinWithSeparator("\n"), curry: curryArgSet)
    }
}
